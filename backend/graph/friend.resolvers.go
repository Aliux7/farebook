package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"time"

	"github.com/Aliux7/WEB-KS-231/graph/model"
	"github.com/google/uuid"
)

// CreateFriend is the resolver for the createFriend field.
func (r *mutationResolver) CreateFriend(ctx context.Context, inputFriend model.NewFriend) (*model.Friend, error) {
	now := time.Now()
	friend := &model.Friend{
		ID:         uuid.NewString(),
		UserID:     inputFriend.UserID,
		FriendID:   inputFriend.FriendID,
		Status:     inputFriend.Status,
		CreateDate: now.Format("2006-01-02 15:04:05"),
	}

	return friend, r.DB.Save(&friend).Error
}

// DeleteFriend is the resolver for the deleteFriend field.
func (r *mutationResolver) DeleteFriend(ctx context.Context, userID string, friendID string) (*model.Friend, error) {
	var friend *model.Friend

	if err := r.DB.Where("user_id = ? AND friend_id = ?", userID, friendID).First(&friend).Error; err != nil {
		return nil, err
	}

	if err := r.DB.Delete(&friend).Error; err != nil {
		return nil, err
	}

	return friend, nil
}

// UpdateStatus is the resolver for the updateStatus field.
func (r *mutationResolver) UpdateStatus(ctx context.Context, userID string, friendID string) (*model.Friend, error) {
	var friend *model.Friend

	if err := r.DB.Where("user_id = ? AND friend_id = ?", userID, friendID).First(&friend).Error; err != nil {
		return nil, err
	}

	friend.Status = "approved"

	if err := r.DB.Save(&friend).Error; err != nil {
		return nil, err
	}

	return friend, nil
}

// GetAllFriendRequest is the resolver for the getAllFriendRequest field.
func (r *queryResolver) GetAllFriendRequest(ctx context.Context, id string) ([]*model.Friend, error) {
	var friendRequests []*model.Friend

	if err := r.DB.Where("user_id = ? AND status = ?", id, "request").Find(&friendRequests).Error; err != nil {
		return nil, err
	}

	return friendRequests, nil
}

// GetAllFriends is the resolver for the getAllFriends field.
func (r *queryResolver) GetAllFriends(ctx context.Context, id string) ([]*model.Friend, error) {
	var friendRequests []*model.Friend

	if err := r.DB.Where("user_id = ? AND status = ?", id, "approved").Find(&friendRequests).Error; err != nil {
		return nil, err
	}

	return friendRequests, nil
}

// GetUserSuggestions is the resolver for the getUserSuggestions field.
func (r *queryResolver) GetUserSuggestions(ctx context.Context, id string) ([]*model.User, error) {
	var userFriends []*model.Friend
	if err := r.DB.Where("user_id = ?", id).Find(&userFriends).Error; err != nil {
		return nil, err
	}

	// Get the user's friend IDs
	var friendIDs []string
	for _, friend := range userFriends {
		friendIDs = append(friendIDs, friend.FriendID)
	}

	// Get the friends of the user's friends
	var friendsOfFriends []*model.Friend
	if err := r.DB.Where("user_id IN ?", friendIDs).Find(&friendsOfFriends).Error; err != nil {
		return nil, err
	}

	// Filter out friends of the user and friends of friends
	suggestedFriendIDs := make(map[string]bool)
	for _, fof := range friendsOfFriends {
		if fof.FriendID != id && !contains(friendIDs, fof.FriendID) {
			suggestedFriendIDs[fof.FriendID] = true
		}
	}

	// Get the details of suggested friends
	var suggestedFriends []*model.User
	if err := r.DB.Where("id IN ?", keys(suggestedFriendIDs)).Find(&suggestedFriends).Error; err != nil {
		return nil, err
	}

	return suggestedFriends, nil
}

// IsFriend is the resolver for the isFriend field.
func (r *queryResolver) IsFriend(ctx context.Context, userID string, friendID string) (bool, error) {
	var friendship *model.Friend

	err := r.DB.Model(&model.Friend{}).
		Where("user_id = ? AND friend_id = ? AND status = ?", userID, friendID, "approved").
		First(&friendship).Error

	if err != nil {
		return false, err
	}

	return true, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
func keys(m map[string]bool) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

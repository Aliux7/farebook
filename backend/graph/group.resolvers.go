package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"strings"
	"time"

	"github.com/Aliux7/WEB-KS-231/graph/model"
	"github.com/google/uuid"
)

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, inputGroup model.NewGroup) (*model.Group, error) {
	now := time.Now()
	group := &model.Group{
		ID:         uuid.NewString(),
		Name:       inputGroup.Name,
		Privacy:    inputGroup.Privacy,
		CreateDate: now.Format("2006-01-02 15:04:05"),
	}

	return group, r.DB.Save(&group).Error
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string) (*model.Group, error) {
	var group *model.Group

	if err := r.DB.First(&group, "id = ?", id).Error; err != nil {
		return nil, err
	}
	return group, r.DB.Delete(&group).Error
}

// SearchAllGroup is the resolver for the searchAllGroup field.
func (r *queryResolver) SearchAllGroup(ctx context.Context, search string) ([]*model.Group, error) {
	var groups []*model.Group
	query := r.DB

	if search != "" {
		query = query.Where("LOWER(name) LIKE ?", "%"+strings.ToLower(search)+"%")
	}

	if err := query.Find(&groups).Error; err != nil {
		return nil, err
	}

	return groups, nil
}

// GetGroupByID is the resolver for the getGroupByID field.
func (r *queryResolver) GetGroupByID(ctx context.Context, id string) (*model.Group, error) {
	var group *model.Group
	return group, r.DB.First(&group, "id = ?", id).Error
}

// GetJoinedGroups is the resolver for the getJoinedGroups field.
func (r *queryResolver) GetJoinedGroups(ctx context.Context, userID string) ([]*model.Group, error) {
	var groupIDs []string

	err := r.DB.Model(&model.GroupMember{}).
		Where("user_id = ?", userID).
		Pluck("group_id", &groupIDs).
		Error
	if err != nil {
		return nil, err
	}

	// Step 2: Get all data of groups using group IDs
	var groups []*model.Group
	err = r.DB.Where("id IN ?", groupIDs).Find(&groups).Error
	if err != nil {
		return nil, err
	}

	return groups, nil
}

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"fmt"
	"time"

	"github.com/Aliux7/WEB-KS-231/graph/model"
	"github.com/google/uuid"
)

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, inputChat *model.NewChat) (*model.Chat, error) {
	now := time.Now()
	chat := &model.Chat{
		ID:        uuid.NewString(),
		UserID1:   inputChat.UserID1,
		UserID2:   inputChat.UserID2,
		CreatedAt: now.Format("2006-01-02 15:04:05"),
	}

	// Save the chat to the database
	if err := r.DB.Save(&chat).Error; err != nil {
		return nil, err
	}

	return chat, nil
}

// CreateMessage is the resolver for the createMessage field.
func (r *mutationResolver) CreateMessage(ctx context.Context, inputMessage model.NewMessage) (*model.Message, error) {
	now := time.Now()
	message := &model.Message{
		ID:        uuid.NewString(),
		ChatID:    inputMessage.ChatID,
		Sender:    inputMessage.Sender,
		Content:   inputMessage.Content,
		Timestamp: now.Format(time.RFC3339),
	}

	// Save the message to the database
	if err := r.DB.Save(&message).Error; err != nil {
		return nil, err
	}

	for _, conn := range r.Conns {
		fmt.Println(conn)
		err := conn.WriteJSON(&message)
		if err != nil {
			fmt.Println(err)
		}
	}

	return message, nil
}

// GetAllMessageByChat is the resolver for the getAllMessageByChat field.
func (r *queryResolver) GetAllMessageByChat(ctx context.Context, id *string) ([]*model.Message, error) {
	var messages []*model.Message
	err := r.DB.Where("chat_id = ?", id).Order("timestamp ASC").Find(&messages).Error
	if err != nil {
		return nil, err
	}
	return messages, nil
}

// GetChoosenChat is the resolver for the getChoosenChat field.
func (r *queryResolver) GetChoosenChat(ctx context.Context, userID1 *string, userID2 *string) (*string, error) {
	var chats []*model.Chat
	err := r.DB.Where("user_id1 = ? OR user_id2 = ?", userID1, userID1).Find(&chats).Error
	if err != nil {
		return nil, err
	}

	var chatID *string

	for _, chat := range chats {
		if chat.UserID1 == chat.UserID2 {
			if chat.UserID1 == *userID2 && chat.UserID2 == *userID1 {
				chatID = &chat.ID
				break
			}
		} else {
			if (chat.UserID1 == *userID1 && chat.UserID2 == *userID2) || (chat.UserID1 == *userID2 && chat.UserID2 == *userID1) {
				chatID = &chat.ID
				break
			}
		}
	}

	if chatID == nil {
		return nil, nil
	}

	return chatID, nil
}

// GetAllUserChat is the resolver for the getAllUserChat field.
func (r *queryResolver) GetAllUserChat(ctx context.Context, userID string) ([]string, error) {
	var chats []*model.Chat
	err := r.DB.Where("user_id1 = ? OR user_id2 = ?", userID, userID).Find(&chats).Error
	if err != nil {
		return nil, err
	}

	otherUserIDs := make([]string, 0)
	for _, chat := range chats {
		if chat.UserID1 == userID {
			otherUserIDs = append(otherUserIDs, chat.UserID2)
		} else {
			otherUserIDs = append(otherUserIDs, chat.UserID1)
		}
	}

	return otherUserIDs, nil
}

// GetConversationMessageByChat is the resolver for the getConversationMessageByChat field.
func (r *queryResolver) GetConversationMessageByChat(ctx context.Context, userID1 *string, userID2 *string) ([]*model.Message, error) {
	var chats []*model.Chat
	err := r.DB.Where("user_id1 = ? OR user_id2 = ?", userID1, userID1).Find(&chats).Error
	if err != nil {
		return nil, err
	}

	var chatID string

	for _, chat := range chats {
		if chat.UserID1 == chat.UserID2 {
			if chat.UserID1 == *userID2 && chat.UserID2 == *userID1 {
				chatID = chat.ID
				break
			}
		} else {
			if (chat.UserID1 == *userID1 && chat.UserID2 == *userID2) || (chat.UserID1 == *userID2 && chat.UserID2 == *userID1) {
				chatID = chat.ID
				break
			}
		}
	}

	if chatID == "" {
		// Chat not found
		return nil, nil
	}

	// Retrieve messages using chat ID
	return r.GetAllMessageByChat(ctx, &chatID)
}

// NewMessage is the resolver for the newMessage field.
func (r *subscriptionResolver) NewMessage(ctx context.Context) (<-chan []*model.Message, error) {
	ch := make(chan []*model.Message)

	go func() {
		for {
			time.Sleep(1 * time.Second)

			// messages, err := r.Query().GetAllMessage(ctx)
			// if err != nil {
			// 	fmt.Println("Error fetching messages:", err)
			// 	continue
			// }

			// select {
			// case <-ctx.Done():
			// 	fmt.Println("Tick")
			// 	close(ch) // Close the channel when the subscription is closed
			// 	return

			// fmt.Println("Tick")
			// fmt.Println(ctx.Deadline())
			// fmt.Println(ctx.Done())
			// ch <- messages
			// Messages sent, continue
			// }
		}
	}()

	fmt.Println("MASOKKK")
	fmt.Println(ch)
	return ch, nil
}

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
